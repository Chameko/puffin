
// This file is automatically generated. DO NOT EDIT. To generate run `cargo run gen-syntax`

use SyntaxKind::*;

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
#[allow(non_camel_case_types)]
pub enum SyntaxKind {
    // Special syntax kinds that may appear during parsing but never make it into the final tree
    #[doc(hidden)]
    EOF,
    AMP,
    PIPE,
    PLUS,
    MINUS,
    STAR,
    SLASH,
    GT,
    LT,
    EQ,
    L_PAREN,
    R_PAREN,
    EXCLAMATION,
    EQEQ,
    GTEQ,
    LTEQ,
    AMPAMP,
    PIPEPIPE,
    OR_KW,
    AND_KW,
    INT,
    FLOAT,
    STRING,
    ERROR,
    IDENT,
    WHITESPACE,
    COMMENT,
    SOURCE_FILE,
    LITERAL,
    EXPR_STMT,
    BIN_EXPR,// Allows for casting from u16 safely
    __LAST,
}

macro_rules! T {
    (&) => {
        $crate::SyntaxKind::AMP
    };
    (|) => {
        $crate::SyntaxKind::PIPE
    };
    (+) => {
        $crate::SyntaxKind::PLUS
    };
    (-) => {
        $crate::SyntaxKind::MINUS
    };
    (*) => {
        $crate::SyntaxKind::STAR
    };
    (/) => {
        $crate::SyntaxKind::SLASH
    };
    (>) => {
        $crate::SyntaxKind::GT
    };
    (<) => {
        $crate::SyntaxKind::LT
    };
    (=) => {
        $crate::SyntaxKind::EQ
    };
    ('(') => {
        $crate::SyntaxKind::L_PAREN
    };
    (')') => {
        $crate::SyntaxKind::R_PAREN
    };
    (!) => {
        $crate::SyntaxKind::EXCLAMATION
    };
    (==) => {
        $crate::SyntaxKind::EQEQ
    };
    (>=) => {
        $crate::SyntaxKind::GTEQ
    };
    (<=) => {
        $crate::SyntaxKind::LTEQ
    };
    (&&) => {
        $crate::SyntaxKind::AMPAMP
    };
    (||) => {
        $crate::SyntaxKind::PIPEPIPE
    };
    (or) => {
        $crate::SyntaxKind::OR_KW
    };
    (and) => {
        $crate::SyntaxKind::AND_KW
    };
}

impl SyntaxKind {
    #[rustfmt::skip]
    pub fn is_keyword(self) -> bool {
        matches!(self,
        OR_KW
        | AND_KW
        )
    }

    #[rustfmt::skip]
    pub fn is_symbol(self) -> bool {
        matches!(self,
        AMP
        | PIPE
        | PLUS
        | MINUS
        | STAR
        | SLASH
        | GT
        | LT
        | EQ
        | L_PAREN
        | R_PAREN
        | EXCLAMATION
        | EQEQ
        | GTEQ
        | LTEQ
        | AMPAMP
        | PIPEPIPE
        )
    }

    #[rustfmt::skip]
    pub fn is_literal(self) -> bool {
        matches!(self,
            INT
            | FLOAT
            | STRING
        )
    }
}


impl From<u16> for SyntaxKind {
    fn from(d: u16) -> SyntaxKind {
        assert!(d <= (SyntaxKind::__LAST as u16));
        unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }
    }
}

impl From<SyntaxKind> for u16 {
    fn from(k: SyntaxKind) -> u16 {
        k as u16
    }
}